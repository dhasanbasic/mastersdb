-----------------------------------
  TODO list for MastersDB project
-----------------------------------
                      Copyright (C) 2010, Dinko Hasanbasic (dinkoh@bih.net.ba)

General
-------    
  * implement support for following data types (sorted by name length):
    ** NAME            NAME LENGTH   SIZE (B)  COMPARISON FUNCTION
       FLAG            4             1         N/A
       FLOAT           5             4         assembly -> CompareFloat
       DOUBLE          6             8         assembly -> CompareDouble
       BINARY          6             4 + N*1   N/A
       INTEGER         7             4         Standard C -> memcmp
       CURRENCY        8             4+1+16    assebmly -> CompareFloat
        (Float+Symbol)
       ISOSTRING       9             4 + N*1   Standard C -> strncmp
       UTF8STRING      10            4 + N*1   Standard C -> strncmp
       UTF16STRING     11            4 + N*2   C/assembly -> CompareUnicode
       LONG DOUBLE     11            12        assembly -> CompareLongDouble
       LONG INTEGER    12            8         assembly -> CompareLongInteger
    
    ** design a hash function for the type name to index conversion, so types
       can be stored in a "type table" and quickly accesses by name
       
    ** design and implement the missing type comparison functions
  
  * design a file format for storing B-trees:
    # 512 Bytes Header with:
      - MastersDB magic number, format identification
      - Pointer to first B-tree descriptor block
      - Pointer to first free list block
    # 1-4 KB-blocks of following types:
      - 1 KB: B-tree descriptor storage
      - 1 KB: Free list storage
      - 4 KB: B-tree node storage
      - 4 KB: B(plus)-tree key storage

Optimizations
-------------
  * General
    - Assume preallocated BtreeNode structures in ReadNode/WriteNode
      implementations.
            
  * btree.c:
    - Use binary search during insert/delete, instead of sequential.
    - Write iterative versions of insert/delete.

Ideas
-----
  * btree.h, btree.c
    - Instead of using unsigned long as child pointer to a node, use void*,
      store the child pointer size in the Btree structure and let ReadNode/
      WriteNode take care of what to do with that pointer. With such
      implementation, in-memory and in-file B-trees can be easier implemented.
