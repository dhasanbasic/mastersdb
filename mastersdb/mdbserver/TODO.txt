-----------------------------------
  TODO list for MastersDB project
-----------------------------------
                      Copyright (C) 2010, Dinko Hasanbasic (dinkoh@bih.net.ba)

General
-------    
  * implement support for following data types (sorted by name length):
    ** NAME          NAME  HEADER  SIZE (B)  COMPARISON FUNCTION
       FLAG           4    0       1         Standard C -> memcmp
       FLOAT          5    0       4         assembly   -> CompareFloat
       DOUBLE         6    0       8         assembly   -> CompareDouble
       BINARY         6    4       N*1       N/A
       INTEGER        7    0       4         Standard C -> memcmp
       ISOSTRING      9    4       N*1       Standard C -> strncmp
       UNISTRING      9    4       N*2       C/assembly -> CompareUnicode
       UTF8STRING    10    4       N*1       Standard C -> strncmp
       LONG DOUBLE   11    0       12        assembly   -> CompareLongDouble
       LONG INTEGER  12    0       8         Standard C -> memcmp
       
    ** design and implement the missing type comparison functions:
      - mdbCompareFloat
      - mdbCompareDouble
      - mdbCompareUnicode
      - mdbCompareLongDouble
  
  * design a file format for storing B-trees:
    # 512 Bytes Header with:
      - MastersDB magic number, format identification
      - Pointer to first B-tree descriptor block
      - Pointer to first free list block
    # 1-4 KB-blocks of following types:
      - 1 KB: B-tree descriptor storage
      - 1 KB: Free list storage
      - 4 KB: B-tree node storage
      - 4 KB: B(plus)-tree key storage

Optimizations
-------------
  * General
    - Assume preallocated BtreeNode structures in ReadNode/WriteNode
      implementations.
            
  * btree.c:
    - Use binary search during insert/delete, instead of sequential.
    - Write iterative versions of insert/delete.

Ideas
-----
  * btree.h, btree.c
    - Instead of using unsigned long as child pointer to a node, use void*,
      store the child pointer size in the Btree structure and let ReadNode/
      WriteNode take care of what to do with that pointer. With such
      implementation, in-memory and in-file B-trees can be easier implemented.
