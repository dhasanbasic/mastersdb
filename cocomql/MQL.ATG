/*
 * MQL.ATG
 *
 * MastersDB query language (MQL) grammar description for Coco/R
 *
 * Copyright (C) 2010, Dinko Hasanbasic (dinkoh@bih.net.ba)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 *
 * Revision history
 * ----------------
 * 22.07.2010
 *  Initial version of file.
 * 12.08.2010
 *  Added rules for CREATE TABLE statement.
 * 13.08.2010
 *  Added rules for INSERT INTO statement.
 * 14.08.2010
 *  Changed the special character set.
 * 15.08.2010
 *  Added the getOffset method.
 *  Added rules for DESC statement.
 * 16.08.2010
 *  Added rules for SELECT.
 *  Added support for multi-column select.
 */

extern "C" {
  #include "../mdb.h"
}

#include "../mvm/mdbVirtualMachine.h"
#include "MQLSelect.h"

#include <string>

using namespace MDB;
using namespace std;

COMPILER MQL

static const uint32 BUFFER_SIZE = 1024;
char buf[BUFFER_SIZE];
mdbVirtualMachine *VM;
MQLSelect *select;

uint16 dp;
uint16 tp;

string* TokenToString()
{
  wcstombs(buf, t->val, BUFFER_SIZE);
  return new string(buf);
}

uint32 getOffset(const void* src, const void* dest)
{
  return (uint32)((char*)dest - (char*)src);
}

void setVM (mdbVirtualMachine *vm)
{
  VM = vm;
}

void setSelect (MQLSelect *select)
{
  this->select = select;
}

/* ignores case */
IGNORECASE

/* defines the character sets */
CHARACTERS

  /* Special characters in identifiers: Č Ć Đ Š Ž Ä Ö Ü č ć đ š ž ä ö ü */
  special           = '\u010c' + '\u0106' + '\u0110' + '\u0160' + '\u017d'
                    + '\u00c4' + '\u00d6' + '\u00dc' + '\u010d' + '\u0107'
                    + '\u0111' + '\u0161' + '\u017e' + '\u00e4' + '\u00f6'
                    + '\u00fc'.
  /* Whitespace */
  whitespace        = '\u0009' .. '\u000d' + '\u0020'.
  
  /* "Quotes" and 'Apostrophe' strings */
  qstr              = ANY - '\\' - '\"'.
  astr              = ANY - '\\' - '\''.
  
  /* Digits, operators and identifier letters */
  digit             = "0123456789".
  operator          = "<=>".
  letter            = 'A' .. 'Z' + 'a' .. 'z' + special.
/* defines the tokens */
TOKENS
  NUMBER	        = digit {digit}.
  IDENTIFIER        = letter {letter}.
  COLUMN            = letter {letter} '.' letter {letter}.
  STRING            = '\"' { qstr | '\\' '\'' } '\"' |
                      '\'' { astr | '\\' '\"' } '\''.
  OPERATOR          = operator | "<=" | ">=" | "<>".

/* defines the comments */
COMMENTS FROM "/*" TO "*/"

IGNORE whitespace

/* defines the productions */
PRODUCTIONS

/*
 * MastersDB Query Language
 */

MQL =
  ( MQLCreateStatement
  | MQLInsertStatement
  | MQLDescribeStatement
  | MQLSelectStatement )
  ';'

(.
  VM->AddInstruction(mdbVirtualMachine::HALT,
     mdbVirtualMachine::MVI_SUCCESS);
.) .

/*
 * CREATE TABLE
 */

MQLCreateStatement =

(.
  string *s;
  char *name;
  uint16 ncp;
  dp = 0;
  tp = 0;
.)

  "CREATE" "TABLE"
  
  IDENTIFIER
  
(.
  VM->AddInstruction(mdbVirtualMachine::SETTBL, tp);
  s = TokenToString();
  name = (char*)malloc(s->length() + 4);
  *((uint32*)name) = s->length();
  strncpy(name + 4, s->c_str(), s->length());
  delete s;
  ncp = dp;
  VM->StoreData(name, dp++);
.)
                           
  '(' MQLAttributes ')'

(. VM->AddInstruction(mdbVirtualMachine::CRTTBL, ncp); .) .

/*
 * MQL attributes
 */

MQLAttributes = MQLAttribute<true> {',' MQLAttribute<false> }.

/*
 * MQL attribute
 */

MQLAttribute<bool first> =

(.
  string *s;
  char *name;
  uint16* type_indexed;
  uint32* length = NULL;
  bool has_length;
.) 

  IDENTIFIER

(.
  s = TokenToString();
  name = (char*)malloc(s->length() + 4);
  *((uint32*)name) = s->length();
  strncpy(name+4, s->c_str(), s->length());
  delete s;
  
  type_indexed = (uint16*)malloc(sizeof(uint16));
  *type_indexed = (first) ? 0xFF01 : 0xFF00;
.)
                           
  MQLDatatype<type_indexed, has_length>

(. if (has_length) length = (uint32*)malloc(sizeof(uint32)); .)
  
  { '(' NUMBER

(.
  s = TokenToString();
  *length = atoi(s->c_str());
  delete s;
.)

  ')' }

(.
  if (has_length)
  {
      // stores the column length and pushes its address
      VM->AddInstruction(mdbVirtualMachine::PUSH, dp);
      VM->StoreData((char*)length, dp++);
  }
  // stores the column type information and pushes its address
  VM->AddInstruction(mdbVirtualMachine::PUSH, dp);
  VM->StoreData((char*)type_indexed, dp++);
  // stores the column name
  VM->StoreData(name, dp);
  // now the column can be created
  VM->AddInstruction(mdbVirtualMachine::NEWCOL, dp++);
.) .

/*
 * MQL data type
 */

MQLDatatype<uint16* type_indexed, bool &has_length> =

    "INT-8"      (. (*type_indexed) &= 0x0001; has_length = false; .)
  | "INT-16"     (. (*type_indexed) &= 0x0101; has_length = false; .)
  | "INT-32"     (. (*type_indexed) &= 0x0201; has_length = false; .)
  | "FLOAT"      (. (*type_indexed) &= 0x0301; has_length = false; .)
  | "STRING"     (. (*type_indexed) &= 0x0401; has_length = true; .) .

/*
 * INSERT INTO
 */

MQLInsertStatement =

(.
  string *s;
  char *name;
  dp = 0;
  tp = 0;
.)

  "INSERT" "INTO" IDENTIFIER

(.
  VM->AddInstruction(mdbVirtualMachine::SETTBL, tp);
  s = TokenToString();
  name = (char*)malloc(s->length() + 4);
  *((uint32*)name) = s->length();
  strncpy(name + 4, s->c_str(), s->length());
  delete s;
  VM->AddInstruction(mdbVirtualMachine::LDTBL, dp);
  VM->StoreData(name, dp++);
.)

  "VALUES" '(' MQLValues ')'

(. VM->AddInstruction(mdbVirtualMachine::INSREC, tp); .) .

/*
 * MQLValues
 */

MQLValues = MQLValue { ',' MQLValue } .

/*
 * MQLValue
 */
MQLValue =

(.
  string *s;
  char *data;
.)

  ( NUMBER

(.
  s = TokenToString();
  data = (char*)malloc(sizeof(uint32));
  *data = atoi(s->c_str());
.)

  | STRING

(.
  s = TokenToString();
  data = (char*)malloc(s->length() + 4);
  *((uint32*)data) = s->length() - 2;
  strncpy(data + 4, s->c_str() + 1, s->length() - 2);
.)

  )

(.
  VM->AddInstruction(mdbVirtualMachine::INSVAL, dp);
  VM->StoreData(data, dp++);
  delete s; 
.) .

/*
 * DESC
 */

MQLDescribeStatement =

(.
  string *s;
  char *name;
  dp = 0;
  tp = 0;
.)

  ("DESC" | "DESCRIBE") IDENTIFIER

(.
  VM->AddInstruction(mdbVirtualMachine::SETTBL, tp);
  s = TokenToString();
  name = (char*)malloc(s->length() + 4);
  *((uint32*)name) = s->length();
  strncpy(name + 4, s->c_str(), s->length());
  delete s;
  VM->AddInstruction(mdbVirtualMachine::LDTBL, dp);
  VM->StoreData(name, dp++);
  VM->AddInstruction(mdbVirtualMachine::DSCTBL, tp);
.) .

/*
 * SELECT
 */

MQLSelectStatement =

(.
  dp = 0;
  tp = 0;
  select->Reset();
.)

  "SELECT" MQLColumns "FROM" MQLTables

(.
  select->setDataPointer(dp);
  select->GenerateBytecode();
.) .

/*
 * MQLColumns
 */
MQLColumns =

(.
  string *table = NULL;
  string *column = NULL;
.)
                           
  '*'
(.
  column = new string("*");
  if (select->MapColumn(column, table, dp))
  {
     dp++;
  };
  delete column;
.)

  | MQLColumn {',' MQLColumn} .

/*
 * MQLColumn
 */
MQLColumn =

(.
  string *table = NULL;
  string *column = NULL;
  string *tmp = NULL;
  uint32 dot;
.)

  ( COLUMN

(.
  tmp = TokenToString();
  dot = tmp->find('.');
  table = new string(tmp->c_str(),dot);
  column = new string(tmp->c_str() + dot + 1);
.)

  |  IDENTIFIER
  
(. column = TokenToString(); .)

  )

(.
  if (select->MapColumn(column, table, dp))
  {
     dp++;
  };
  delete table;
  delete column;
  delete tmp;
.) .

/*
 * MQLTables
 */
MQLTables = MQLTable {',' MQLTable} .

/*
 * MQLTable
 */
MQLTable =

(. string *table = NULL; .)

  IDENTIFIER

(.
  table = TokenToString();
  select->MapTable(table, tp);
  tp++;
  delete table;
.) .

END MQL .
